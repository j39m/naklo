#!/usr/bin/env python3

# pyaklon shamefacedly comes crawling back to Python.
# It was fun writing naklo in Perl, but it grew difficult
# to maintain. Therefore...

from pyaFiles import controlFile, titleFile, listingFile
import argparse
import sys

MY_NAME = "pyaklon"


class pyaklon(object):

    def __init__(self, *args):
        args = self._prep_args(*args)

        try:
            # listing file (which also tells us how many files to
            # operate on
            errlevel = str("listingFile %s" % args.listing)
            self.listingFile = listingFile(args.listing, None)
            self.numFiles = self.listingFile.countTagees()
            # titles file
            errlevel = str("titleFile %s" % args.titles)
            self.titleFile = titleFile(args.titles, self.numFiles)
            # control file
            errlevel = str("controlFile %s " % args.control)
            self.controlFile = controlFile(args.control, self.numFiles)
        except FileNotFoundError:
            errstr = str("%s was not found!" % errlevel)
            self.pyaErr(errstr, 1)

    def _prep_args(self, *args):
        ap = argparse.ArgumentParser()
        ap.add_argument("-l", "--listing",
                        help="name of listing file (typically "
                        "a shell redirect)",)
        ap.add_argument("-t", "--titles",
                        help="name of titles file",)
        ap.add_argument("-c", "--control",
                        help="name of control file",)
        args = ap.parse_args()

        compulsory = (args.listing
                      and args.titles
                      and args.control)
        if not compulsory:
            ap.print_help()
            errstr = ("\nHint: you probably want to provide all three "
                      "arguments. The listing file is typically a shell "
                      "redirect, like `<(ls ./*.flac)'.")
            self.pyaErr(errstr, 1)
        return args

    def pyaErr(self, msg, bailcode=None):
        sys.stderr.write("%s\n" % msg)
        if bailcode is not None:
            sys.exit(bailcode)

    def checkSanity(self):
        """
        Display errors in inputs; bail if these are nonzero.
        """
        insanity = None
        for f in (self.listingFile,
                  self.titleFile,
                  self.controlFile):
            if f.checkSanity():
                insanity = "\n".join(f.showInsanity())
                self.pyaErr(insanity)
        if insanity:
            self.pyaErr("One or more errors detected. Aborting.", 1)

    def main(self):
        """
        The main flow of execution. Call this, it's what you want.
        """

        self.checkSanity()

        # list files as dict, each with of list of tag=value to apply.
        # this way, we can bundle all the tags into one metaflac call,
        # something which we didn't do in the old Perl naklo.
        files_d = {}
        file_index = self.listingFile.enumerateTagees()
        for f in file_index:
            files_d[f] = []

        # gather titles
        for p in zip(file_index, self.titleFile.enumerateTitles()):
            files_d[p[0]] = "title=%s" % p[1]

        # gather other directives
        d = self.controlFile.enumerateDirectives()
        for directive in d:
            (files, tag, value) = directive
        return 0


if __name__ == "__main__":
    runner = pyaklon(*sys.argv[1:])
    sys.exit(runner.main())
