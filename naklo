#!/usr/bin/python3
"""
naklo is a batch FLAC tagger.
"""

import sys
import argparse
import libnaklo


def parse_args():
    """Construct and return an argument parser."""
    parser = argparse.ArgumentParser(
        description="provide templates with which to tag FLAC files."
    )
    parser.add_argument(
        "-c", "--control-file", action="append",
        help="File of YAML-formatted control blocks",
    )
    parser.add_argument(
        "-t", "--title-file", action="append",
        help="File full of newline-separated titles",
    )
    parser.add_argument(
        "-m", "--use-metaflac", action="store_true",
        help="Force naklo to tag with metaflac",
    )
    parser.add_argument(
        "songs", nargs=argparse.REMAINDER, metavar="<target files to tag>"
    )

    return parser.parse_args()


def main():
    """Read, process, and write tags."""
    args = parse_args()

    controls = list()
    titles = list()

    # For now, we force metaflac usage when tagging songs.
    # TODO(j39m): change this!
    args.use_metaflac = True

    songs = libnaklo.songs_to_array(
        *args.songs,
        use_metaflac=args.use_metaflac
    )

    # Control blocks are ``universal'' in scope.
    if args.control_file:
        for cfn in args.control_file:
            controls.extend(libnaklo.controls_to_array(cfn))
    # Title files each represent one sweep by themselves. Each file is
    # a fresh pass at the whole songs array; they do not build on each
    # other.
    if args.title_file:
        for tfn in args.title_file:
            titles.append(libnaklo.titles_to_array(tfn))

    for ctl in controls:
        ctl.apply_to_songs(songs)
    for t_arr in titles:
        libnaklo.apply_titles_to_songs(t_arr, songs)
    libnaklo.number_tracks(songs)

    for song in songs:
        if song.do_tag():
            print(song.path)
            print(song.last_stodut)
            print(song.last_stderr)

    return 0

if __name__ == "__main__":
    sys.exit(main())
