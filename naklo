#! /usr/bin/env perl

# Naklo on the river Notec! 
# It's a sequential tagger intended to slap easily-patterned tags
# from a controlling text file onto a fresh rip of a bunch of
# FLAC files. It does so by calling metaflac, a dependency for 
# this script. 

use strict; 
use warnings; 
use Getopt::Std; 


# gen_files takes no arguments and produces a list of FLAC files
# in the current directory for naklo to process. It will be called
# in the absence of a user-provided list of files to process. 

sub gen_files { 

  print STDERR "You have not provided a list of files to "
    . "operate upon. naklo will assume you mean to operate "
    . "on all FLAC files in the current working directory.\n\n";

  my @listing_arr = (); 
  opendir (my $currentdir, $ENV{"PWD"})
    or die $!; 
  while (my $file = readdir($currentdir)) { 
    next unless ($file =~ m/\.flac$/); 
    if (-f $file) { 
      push (@listing_arr, "\"$file\""); # quote filenames
    } 
  } 

  closedir ($currentdir); 

  @listing_arr = sort @listing_arr; 
  my $length = @listing_arr; 
  if ($length == 0) { 
    print STDERR "No FLAC files found!\n\n"; 
    exit 1; 
  } 

  print STDERR "The listing of files, in order, is given: \n"; 
  for my $enttry (@listing_arr) { 
    print "$enttry; "; 
  } 
  print "\n\n"; 

  print STDERR " Do you wish to continue? [y/n]: ";
  my $continue = <STDIN>; 
  print "\n\n"; 
  $continue = substr ($continue, 0, 1); 
  if ( $continue eq "k" ) { 
    print "Ok\n"; 
  } elsif ( $continue ne "y" ) { 
    print "Exiting.\n"; 
    exit 0; 
  } 

  return @listing_arr; 

} 


# tag_num takes a list of files and tags track numbers 
# sequentially, assuming that order follows as in the array. 

sub tag_num { 

  my $i = 1; 
  
  for my $particular_file (@_) { 
    # CHANGE ME
    print "file is $particular_file, numbered $i\n"; 
    $i++; 
  } 

  return; 

} 


# decomment takes a line (a string) from the control file and 
# removes comment material from it. (i.e. ignores all characters
# following a sharp-sign.) It returns the decommented string. 

sub decomment { 

  my @decomment = split ("#", $_[0], 2); 

  if (@decomment == 0) { # empty starter string splits to nothing
    return ""; 
  } 
  
  return $decomment[0]; 

} 


# split_eqchar takes a line (a string) from the control file
# and splits it on the "=" char. It returns the split string 
# as a two-value array. If no "=" is present (e.g. special 
# directive lines), the second value in the array will be an 
# empty string (and you should check for this!). Note that 
# this subroutine trims leading whitespace from the left-hand
# value --- important per the tagfile spec. 

sub split_eqchar { 

  my @tokens = split ("=", $_[0], 2); 

  if (@tokens == 2) { 
    $tokens[1] =~ s/^\s+//; # thanks http://perlmaven.com/trim
  } 

  return @tokens; 

} 


# token_sprout takes a line (a string) from the control file
# and splits it on spaces. Note this automatically trims leading
# white space. This subroutine should be called after splitting 
# on the "=" char to first partition lines into key-value pairs.

sub token_sprout { 

  my @tokens = split (" ", $_[0], -1); 

  return @tokens; 

} 

####################################################
########### THE REAL WORK BEGINS HERE ##############
####################################################

system ("which metaflac > /dev/null 2>&1 "); 
unless ($? == 0) { 
  die "You don't have metaflac installed!\n"; 
} 

my %options = (); 
getopts ("hsc:l:t:", \%options); 
# h: help; s: strip; c: control file; l: file list; t: titles.

if (defined $options{h}) { 
  print "Usage: ./naklo -c [control file] -l [list of files] "
  . "-t [titles file] \n"; 
  print "You may wish to consult the README included with this" 
  . " script.\n"; 
  exit; 
} 
if (!defined $options{c}) { 
  print STDERR "Error: You must provide a control file. Perhaps"
  . " you should consult the README.\n"; 
  exit; 
} # past this point, control file is defined. Try to open it. 

open my $control_file_fp, "<", $options{c} 
  or die "Can't open control file '$options{c}'!\n"; 
my @control_file_lines = <$control_file_fp>; 

my @list_of_files = (); 
my @tmp = (); 
if (defined $options{l}) { 
  open my $list_of_files_fp, "<", $options{l}
    or die "Can't open file list '$options{l}'!\n"; 
  my @tmp = <$list_of_files_fp>; 
  chomp (@tmp); 
  for my $klaus (@tmp) { 
    push (@list_of_files, "\"$klaus\""); 
  } 
  # TODO: gen_files checks for existence. so should readdir method. 
} else { # call gen_files 
  @list_of_files = & gen_files; 
} 


# Here is the BIG loop! 
# and unless ($range =~ m/^[0-9]+[\-][0-9]+$/) ...

my $linecounter = 0; # what line in the control file are we at?
my $numfiles = @list_of_files; # bounds check for file numbers

for my $origline (@control_file_lines) { 

  # internals to be reset per line. 
  my @leftside = (); # all control tokens
  my $rightside = ""; # values
  my $thesefiles = ""; # metaflac $thesefiles --set-tag ...

  $linecounter++; 
  chomp($origline); 

  my $line = & decomment($origline); 

  unless ( $line =~ m/^\s*$/ ) { # unless whitespace line

    my @splitline = & split_eqchar($line);

    if (@splitline != 2) { # if no "=" to split on
      # special directive

    } else { # if we have a left and right side on "="

      @leftside = & token_sprout($splitline[0]); 
      unless ( defined $leftside[0] ) { 
        print "Malformed directive in control file at "
        ."line $linecounter: \"$origline\"\n"; 
        exit 1; 
      } 
      # get number spec from @leftside: 
      if ($leftside[0] =~ m/^[0-9]/) { 
        for my $numtok (@leftside) { 
          if ($numtok =~ m/^[0-9]+$/) { 
            die "Invalid track number spec at line $linecounter:"
            . " \"$numtok\"" if ( ($numtok > $numfiles) 
            or ($numtok < 1) ); 
            # REPLACE BELOW TWO LINES FOR PROPER RANGING ETC. 
            $thesefiles += " "; 
            $thesefiles += $list_of_files[$numtok-1]; 
          } else { # no more numbers to parse 
            last; 
          } 
        } 
      } else { # no number spec; assume _all_ files to be proc'd

      } 

      $rightside = $splitline[1];

    } 
  } 
} 

exit; 
