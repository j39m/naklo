#! /usr/bin/env perl

# Naklo on the river Notec!
# It's a sequential tagger intended to slap easily-patterned tags
# from a controlling text file onto a fresh rip of a bunch of
# FLAC files. It does so by calling metaflac, a dependency for
# this script.

use strict;
use warnings;
use Getopt::Std;


# gen_files takes no arguments and produces a list of FLAC files
# in the current directory for naklo to process. It will be called
# in the absence of a user-provided list of files to process.
sub gen_files {

    print STDERR "You have not provided a list of files to "
        . "operate upon. naklo will assume you mean to operate "
        . "on all FLAC files in the current working directory.\n\n";
    
    my @listing_arr = ();
    opendir (my $currentdir, $ENV{"PWD"})
        or die $!;
    while (my $file = readdir($currentdir)) {
        next unless ($file =~ m/\.flac$/);
        if (-f $file) {
            push (@listing_arr, "\"$file\""); # quote filenames
        }
    }
  
    closedir ($currentdir);
  
    @listing_arr = sort @listing_arr;
    my $length = scalar(@listing_arr);
    if ($length == 0) {
        print STDERR "No FLAC files found!\n\n";
        exit 1;
    }
  
    print STDERR "The listing of files, in order, is given: \n";
    for my $enttry (@listing_arr) {
        print "$enttry; ";
    }
    print "\n\n";
  
    print STDERR " Do you wish to continue? [y/n]: ";
    my $continue = <STDIN>;
    print "\n\n";
    $continue = substr ($continue, 0, 1);
    if ($continue eq "k") {
        print "Ok\n";
    } elsif ($continue ne "y") {
        print "Exiting.\n";
        exit 0;
    }
  
    return @listing_arr;
  
}


# tag_num takes a list of files and tags track numbers
# sequentially, assuming that order follows as in the array.
sub tag_num {

    my $i = 1;
    my $length = scalar(@_);
  
    for my $particular_file (@_) {
        system("metaflac", "--set-tag", "tracknumber=$i",
               "--set-tag", "tracktotal=$length", $particular_file);
        $i++;
    }
  
    return;
  
}


# decomment takes a line (a string) from the control file and
# removes comment material from it. (i.e. ignores all characters
# following a pair of forward slashes.) It returns the decommented
# string.
sub decomment {

    my @decomment = split ("//", $_[0], 2);
  
    if (scalar(@decomment) == 0) { # empty starter string splits to nothing
        return "";
    }
  
    return $decomment[0];
  
}


# split_eqchar takes a line (a string) from the control file
# and splits it on the "=" char. It returns the split string
# as a two-value array. If no "=" is present (e.g. special
# directive lines), the second value in the array will be an
# empty string (and you should check for this!). Note that
# this subroutine trims leading whitespace from the left-hand
# value and trailing whitespace from the right-hand value;
# this is important per the tagfile spec.
sub split_eqchar {

    my @tokens = split ("=", $_[0], 2);
    if (scalar(@tokens) == 2) {
        $tokens[0] =~ s/\s+$//; # thanks http://perlmaven.com/trim
        $tokens[1] =~ s/^\s+//;
    }
    return @tokens;
}


# token_sprout takes a line (a string) from the control file
# and splits it on spaces. Note this automatically trims leading
# white space. This subroutine should be called after splitting
# on the "=" char to first partition lines into key-value pairs.
sub token_sprout {
    my ($line) = @_;
    my @tokens = split (" ", $line, -1);
    return \@tokens;
}


# is_valid_tag takes a string and tests it to see if it is a
# valid tag that we can apply safely.
sub is_valid_tag {

    return (($_[0] eq "artist")
            or ($_[0] eq "albumartist")
            or ($_[0] eq "performer")
            or ($_[0] eq "conductor")
            or ($_[0] eq "composer")
            or ($_[0] eq "arranger")
            or ($_[0] eq "lyricist")
            or ($_[0] eq "title")
            or ($_[0] eq "album")
            or ($_[0] eq "location")
            or ($_[0] eq "date")
            or ($_[0] eq "genre")
            or ($_[0] eq "discnumber")
            or ($_[0] eq "disctotal")
            or ($_[0] eq "discsubtitle") );
}


# check_control_file iterates across the control file and
# ensures all directives are properly formed.
# arguments:
#   1. control file fp
#   2. number of files
sub check_control_file {
    
    my ($cffh, $numfiles) = @_;
    my $linecounter = 0;
    my @splitline = ();
    my $left = ();
    my $right = "";

    my $errors_found = 0;

    seek($cffh, 0, 0);
    for my $line (<$cffh>) {

        $linecounter++;
        chomp($line);
        $line = decomment($line);
        
        # HURDLE 1: empty line?
        next if $line =~ m/^\s*$/;

        # HURDLE 2: malformed directive?
        @splitline = split_eqchar($line);
        if (scalar(@splitline) != 2) {
            print "Malformed directive at line $linecounter.\n";
            $errors_found++;
            next;
        }

        # HURDLE 3: proper tokens on both sides?
        $left = token_sprout($splitline[0]);
        $right = $splitline[1];
        if (!scalar(@{$left}) || !defined($right)) {
            print "Malformed directive at line $linecounter.\n";
            $errors_found++;
            next;
        }

        # HURDLE 4: only number specs on the left? 
        # HURDLE 5: does the left-side end only at a valid tag?
        # HURDLE 6: are the number specs all in range?
        my $i = 0;
        for my $ns (@{$left}) {
            if ($ns !~ m/^[0-9]+$/
                    and $ns !~ m/^[0-9]+-[0-9]+$/
                    and !is_valid_tag($ns)) {
                print "Malformed number spec at line $linecounter.\n";
                $errors_found++;
            }
            if ($ns =~ m/^([0-9]+)$/) {
                if (($1 < 1) || ($1 > $numfiles)) {
                    print "Number spec out-of-bounds at line "
                        . "$linecounter.\n";
                    $errors_found++;
                }
            }
            if ($ns =~ m/^([0-9]+)-([0-9]+)$/) {
                if (($1 < 1) || ($1 > $numfiles)) {
                    print "Number spec out-of-bounds at line "
                        . "$linecounter.\n";
                    $errors_found++;
                }
                if (($2 < 1) || ($2 > $numfiles)) {
                    print "Number spec out-of-bounds at line "
                        . "$linecounter.\n";
                    $errors_found++;
                }
                if ($2 <= $1) {
                    print "Number spec is ill-formed at line "
                        . "$linecounter.\n";
                    $errors_found++;
                }
            }
            if (is_valid_tag($ns) && $i != scalar(@{$left}) - 1) {
                print "Premature left-side tag name at line "
                      . "$linecounter.\n";
                $errors_found++;
            }
            $i++;
        }

    }
    seek($cffh, 0, 0);
    return $errors_found;
}


# accumulate filenames from a number spec.
# arguments:
#   1. number spec array
#   2. list of files (as an array reference)
# returns:
#   the space-separated string of requested files
sub accumulate_files {

    my ($nspec, $flist) = @_;
    my @retv = ();

    for my $ns (@{$nspec}) {

        # single number
        if ($ns =~ m/^([0-9]+)$/) {
            push(@retv, $flist->[$ns-1]);

        # range of numbers
        } elsif ($ns =~ m/^([0-9]+)-([0-9]+)$/) {
            my $base = int($1);
            my $bound = int($2);
            while ($base <= $bound) {
                push(@retv, $flist->[$base-1]);
                $base++;
            }
        
        # hit the end - a tag name
        } else {
            last;
        }

    }

    if (!scalar(@retv)) {
        return join(" ", @{$flist});
    }
    return join(" ", @retv);

}


####################################################
########### THE REAL WORK BEGINS HERE ##############
####################################################

system ("which metaflac > /dev/null 2>&1 ");
unless ($? == 0) {
    die "You don't have metaflac installed!\n";
}

my $options = {};
getopts ("hc:l:t:n", $options);
# h: help; c: control file; l: file list; t: titles; n: no-number

if (defined $options->{"h"}) {
    print "Usage: ./naklo -c [control file] -l [list of files] "
    . "-t [titles file] \n";
    print "You may wish to consult the README included with this"
    . " script.\n";
    exit;
}
if ( (!defined $options->{"c"}) and (!defined $options->{"t"}) ) {
    print STDERR "Error: You must provide either a control file"
    . " or a titles file. Perhaps you should consult the README.\n";
    exit 1;
} # past this point, either control or titles file is defined.


# get all the files we want to work with: this is either all FLAC
# files in the directory or specified by an input file containing
# newline-split file listings.
my @list_of_files = ();
my @tmp = ();
if (defined $options->{"l"}) {
    open my $list_of_files_fp, "<", $options->{"l"}
        or die "Can't open file list `$options->{'l'}'!\n";
    my @tmp = <$list_of_files_fp>;
    # trim newline, check existence, quote filenames
    chomp (@tmp);
    for my $tmp_iterator (@tmp) {
        unless (open my $file_iterator, "<", $tmp_iterator) {
            print "Can't open file \"$tmp_iterator\"!\n";
            exit 1;
        }
        push (@list_of_files, $tmp_iterator);
    }
  
} else { # call gen_files
    @list_of_files = gen_files;
}



if (defined $options->{"c"} ) {

    open my $control_file_fp, "<", $options->{"c"}
        or die "Can't open control file `$options->{'c'}'!\n";
    my @control_file_lines = <$control_file_fp>;

    if (check_control_file($control_file_fp, scalar(@list_of_files))) {
        exit 1;
    }
  
    # tag track numbers:
    unless (defined $options->{"n"}) {
        tag_num(@list_of_files);
    }
  
    my $linecounter = 0;
    my $numfiles = scalar(@list_of_files);
  
    my @splitline = (); # the line split on "="
    my $leftside = (); # all control tokens
    my $rightside = ""; # values

    my $thesefiles = ""; # "metaflac $thesefiles --set-tag ..."
    my $tagname = ""; # "... --set-tag $tagname= ..."

    for my $line (@control_file_lines) {

        $linecounter++;

        chomp($line);
        my $line = decomment($line);
        next if ($line =~ m/^\s*$/);

        @splitline = split_eqchar($line);
        $leftside = token_sprout($splitline[0]);
        $rightside = $splitline[1];
        $rightside =~ s/'/'"'"'/;

        $thesefiles = accumulate_files($leftside, \@list_of_files);
        $tagname = $leftside->[-1];

        system("metaflac $thesefiles --set-tag $tagname='$rightside'");

    }
}

if (defined $options->{"t"}) {

    open my $titles_file_fp, "<", $options->{"t"}
        or die "Can't open titles file `$options->{'t'}'!\n";
    my @titles_file_lines = <$titles_file_fp>;
  
    my $num_titles = scalar(@titles_file_lines);
  
    if ($num_titles != scalar(@list_of_files)) {
        print "Number of titles does not match number of files!\n"
            and exit 1;
      
    } else {
        my $i = 0;
        for my $title (@titles_file_lines) {
            chomp ($title);
            $title =~ s/'/'"'"'/g;
            system("metaflac $list_of_files[$i] --set-tag title='$title'");
            $i++;
        }
    
    }
  
}

print "Success!\n";

exit 0;
